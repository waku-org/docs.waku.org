"use strict";(self.webpackChunkwaku_guide=self.webpackChunkwaku_guide||[]).push([[2632],{12137:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/proof-verification-times-c95708ef2a4fc0470114fbceebc6bc30.png"},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(96540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},29651:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/without-rln-8c4f5d9f060feccbadb651f77e9750ca.png"},38493:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/connected-peers-50221f227e3d94be5aeae45193cc04ea.png"},64738:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/proof-generation-times-195632e4864fa4c5f883895f2ea9e9e3.png"},87315:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"learn/research/research-and-studies/rln-key-benchmarks","title":"RLN Key Benchmarks","description":"Introduction","source":"@site/docs/learn/research/research-and-studies/rln-key-benchmarks.md","sourceDirName":"learn/research/research-and-studies","slug":"/learn/research/research-and-studies/rln-key-benchmarks","permalink":"/learn/research/research-and-studies/rln-key-benchmarks","draft":false,"unlisted":false,"editUrl":"https://github.com/waku-org/docs.waku.org/tree/develop/docs/learn/research/research-and-studies/rln-key-benchmarks.md","tags":[],"version":"current","lastUpdatedAt":null,"frontMatter":{"title":"RLN Key Benchmarks"},"sidebar":"learn","previous":{"title":"Message Propagation Times With Waku-RLN","permalink":"/learn/research/research-and-studies/message-propagation"},"next":{"title":"Comparing Waku and libp2p","permalink":"/learn/waku-vs-libp2p"}}');var t=s(74848),r=s(28453);const a={title:"RLN Key Benchmarks"},o=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"TLDR:",id:"tldr",level:2},{value:"Proof generation times",id:"proof-generation-times",level:2},{value:"Proof verification times",id:"proof-verification-times",level:2},{value:"Spam protection",id:"spam-protection",level:2},{value:"RLN tree sync",id:"rln-tree-sync",level:2},{value:"Performance relay vs. rln-relay",id:"performance-relay-vs-rln-relay",level:2}];function d(e){const n={code:"code",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["Since RLN has been chosen as the spamming protection mechanism for waku, we must understand the practical implications of using it. This issue explains the main differences between ",(0,t.jsx)(n.code,{children:"relay"})," and ",(0,t.jsx)(n.code,{children:"rln-relay"})," and gives some benchmarks after running simulations using ",(0,t.jsx)(n.code,{children:"waku-simulator"}),", in a network with the following characteristics:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"100 nwaku nodes, each one with a valid rln membership and publishing a message every 10 seconds to a common topic."}),"\n",(0,t.jsx)(n.li,{children:"rln contract deployed in Ethereum Sepolia"}),"\n",(0,t.jsx)(n.li,{children:"10.000 memberships registered in the contract"}),"\n",(0,t.jsx)(n.li,{children:"pure relay (store and light protocols disabled)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The main deltas ",(0,t.jsx)(n.code,{children:"rln"})," vs ",(0,t.jsx)(n.code,{children:"rln-relay"})," are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["New ",(0,t.jsx)(n.code,{children:"proof "})," field in ",(0,t.jsx)(n.code,{children:"WakuMessage"})," containing 384 extra bytes. This field must be generated and attached to each message."]}),"\n",(0,t.jsxs)(n.li,{children:["New validator, that uses ",(0,t.jsx)(n.code,{children:"proof"})," to ",(0,t.jsx)(n.code,{children:"Accept"})," or ",(0,t.jsx)(n.code,{children:"Reject"})," the message. The proof has to be verified."]}),"\n",(0,t.jsx)(n.li,{children:"New dependency on a blockchain, Ethereum, or any EVM chain, to keep track of the members allowed to publish."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"But what are the practical implications of these?"}),"\n",(0,t.jsx)(n.h2,{id:"tldr",children:"TLDR:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Proof generation is constant-ish. 0.15 second for each proof"}),"\n",(0,t.jsx)(n.li,{children:"Proof verification is constant-ish, 0.012 seconds. In a network with 10k nodes and D=6 this would add an overhead delay of 0.06 seconds."}),"\n",(0,t.jsx)(n.li,{children:"Gossipsub scoring drops connections from spammer peers, which acts as the punishment (instead of slashing). Validated in the simulation."}),"\n",(0,t.jsx)(n.li,{children:"Rln doesn't have any impact on memory consumption."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"proof-generation-times",children:"Proof generation times"}),"\n",(0,t.jsxs)(n.p,{children:["Seems that proof generation times stay constant no matter the size of the message. In the following simulation it was increased from: ",(0,t.jsx)(n.code,{children:"1kB"}),", ",(0,t.jsx)(n.code,{children:"10kB"}),", ",(0,t.jsx)(n.code,{children:"50kB"}),", ",(0,t.jsx)(n.code,{children:"150kB"}),". On average it takes ",(0,t.jsx)(n.code,{children:"0.15 seconds"})," to calculate the message proof. This means that when a node wants to send a message, it will need to spend this time generating the proof. It seems very reasonable and it actually acts as a mini proof of work, where a consumer computer won't be able to publish a really high number of messages per second."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"proof-generation-times",src:s(64738).A+"",width:"1547",height:"1096"})}),"\n",(0,t.jsx)(n.h2,{id:"proof-verification-times",children:"Proof verification times"}),"\n",(0,t.jsxs)(n.p,{children:["On the other hand, rln also adds an overhead in the gossipsub validation process. On average it takes ",(0,t.jsx)(n.code,{children:"0.012 seconds"})," to verify the proof. It seems that when we increase the message size, validation time seems to increase a bit, which can be for any other reason besides rln itself (eg deserializing the message might take longer)."]}),"\n",(0,t.jsxs)(n.p,{children:["This number seems reasonable and shouldn't affect that much the average delay of a message. Assuming a d-regular graph, with ",(0,t.jsx)(n.code,{children:"10k"})," nodes and ",(0,t.jsx)(n.code,{children:"D=6"}),", we can have up to  ",(0,t.jsx)(n.code,{children:"log(total_nodes)/log(D)=5"})," hops. So in the worst case, rln will add a network latency of ",(0,t.jsx)(n.code,{children:"0.012*5 = 0.06 seconds"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"proof-verification-times",src:s(12137).A+"",width:"1564",height:"1214"})}),"\n",(0,t.jsx)(n.h2,{id:"spam-protection",children:"Spam protection"}),"\n",(0,t.jsx)(n.p,{children:"For the initial release of RLN, slashing won't be implemented and it still remains unclear if it will be implemented in the future. Luckily, even if slashing is not implemented rln can be used to detect spam and punish the sender off-chain (instead of slashing an onchain collateral). This is done with gossipsub scoring."}),"\n",(0,t.jsxs)(n.p,{children:["In the following simulation, we can see ",(0,t.jsx)(n.code,{children:"100"})," nwaku interconnected nodes, where one of them suddenly starts spamming the network with multiple valid rln messages ",(0,t.jsx)(n.code,{children:"3000 messages/minute"}),". Since its rate limited to 1msg/10 seconds, we can see that in almost no time, every node in the network disconnects from the spammer peer (see red node), leaving it with ",(0,t.jsx)(n.code,{children:"0 peers"}),", which disincentivise such attacks and without requiring a financial slashing."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"connected-peers",src:s(38493).A+"",width:"1574",height:"1108"})}),"\n",(0,t.jsx)(n.h2,{id:"rln-tree-sync",children:"RLN tree sync"}),"\n",(0,t.jsx)(n.p,{children:"Using RLN implies that waku should now piggyback on a blockchain (the case study uses Ethereum Sepolia) and has to stay up to date with the latest events emitted by the rln smart contract. These events are used to locally construct a tree that contains all members allowed to create valid proofs to send messages. Some numbers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A tree with 10k members takes ",(0,t.jsx)(n.code,{children:"2Mbytes"})," of space. Negligible."]}),"\n",(0,t.jsxs)(n.li,{children:["A tree with 10k members takes ",(0,t.jsx)(n.code,{children:"<4"})," minutes to synchronize. Assumable since it's done just once."]}),"\n",(0,t.jsxs)(n.li,{children:["With a block range of 5000 blocks for each request, we would need ",(0,t.jsx)(n.code,{children:"520 requests"})," to synchronize 1 year of historical data from the tree. Assumable since most of the free endpoints out there allow 100k/day."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-relay-vs-rln-relay",children:"Performance relay vs. rln-relay"}),"\n",(0,t.jsxs)(n.p,{children:["Same simulation with 100 nodes was executed ",(0,t.jsx)(n.code,{children:"with rln"})," and ",(0,t.jsx)(n.code,{children:"without rln"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Memory consumption is almost identical"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"with rln"}),"\n",(0,t.jsx)(n.img,{alt:"with-rln",src:s(93657).A+"",width:"3000",height:"1180"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"without rln"}),"\n",(0,t.jsx)(n.img,{alt:"without-rln",src:s(29651).A+"",width:"2988",height:"1180"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Couldn't capture cpu metrics"}),"\n",(0,t.jsx)(n.li,{children:"Minor differences in messages per seconds is due to injection technique, nothing related to rln itself."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},93657:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/with-rln-65a7cb7bd5c4469c66ca32316d38e320.png"}}]);